#summary definition of the benchmark problem to be solved and rationale for choice

= Introduction =

To be able to test the two GCs, I need a problem that generates a lot of objects and that can be easily scaled to test heavy loads. Ideally, the execution of the test program varies depending on the input data.

This can be achieved by implementing a unix style filter.

= Cesar Shift =

A cesar shift "encrypts" a plaintext by shifting each character in the input alphabet by a constant value, modulo the size of the alphabet. Thus the name "HAL" in space odyssey 2001 is a cesar shift of -1 on the plaintext "IBM" (or so rumor has it.)

This problem is ideal for testing the GCs, since the input data (the plaintext) can be as long as needed. Benchmarking the two GC algorithms can be reduced to timing the execution of the cesar shift algorithm on a very long text.  

Also, the language does not need a lot of facilities:

  * integers (strings can be represented as lists of integers)
  * read a line from stdin (read-line)
  * write a line to stdout (write-line)
  * add two integers (add)
  * basic stack manipulation (swap, dup, rot, pick etc. see HP calculators...)
  * working with lists (list-prepend, list-concat, list-is-empty)

= Example =

Here is an example of how the cesar shift algorithm could be implemented in sina:

{{{

{
   /* 
} :cesar-shift bind

{
   /* execute the cesar shift algorithm on stdin, DS: [] */

   read-line        /* DS: [ list ]
   dup              /* DS: [ list list ]
   list-is-empty    /* DS: [ list int ]
   :break if        /* exit current block if true, DS: [ list ] */
   cesar-shift      /* DS: [ list ]
   write-line       /* DS: [ ]
   loop             /* redo the current block (main) */

} :main bind

main                /* DS: [ empty-list ] */
drop                /* [ ] */

}}}