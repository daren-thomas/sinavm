#summary Documents the progress of this project.

24.08.2007
  Implemented a simple parser and a lexer for the SinaLanguage. So far, there aren't any actions defined, so the parser just works as an acceptor. Nevertheless, it was able to find a syntactic error in the wiki entry for the cesar-shift algorithm. That page has been updated. Also, the source for the parser (sina_parser.y), the lexer (sina_lexer.l), a shell script for building it (test.sh) and the cesar-shift file (cesar_shift.sina) were checked in.
  By end of next week, I plan to implement the actions so that the parser assembles the bytecode for the sina vm. The single linked list I had planned so far as the datatype for sina code and sina lists poses a problem for the parser: Apparently, I am supposed to use left recursive rules as opposed to right recursive rules. Thus, appending a new list_element will either be O(n) for single linked list or O(1) for a more sophisticated data structure.
  I used these links as primers for flex and bison:
  * http://www.cs.utah.edu/dept/old/texinfo/bison/bison.html
  * http://ds9a.nl/lex-yacc-howto.html

26.06.2007
  Project speed has been rather slow so far. Today I finally nailed the [ProjectRequirement]s. This has been nagging me for a while, since it is not much of a chore (this is an exploration type project with a single main goal), but needs to be done before I can allow myself to continue with the design of the system. I expect the basic design to be finished by this time next week so I can start coding.

07.06.2007
  After watching [http://video.google.com/videoplay?docid=2139967204534450862&q=hashtable this video on lock-free hashtables] I believe it might be possible to avoid locking in most cases for the GC. In Dijkstras GC algorithm, only the GC ever changes the current colour. The allocator (running in the interpreter thread) needs only to read the current colour and notice when it changes (compare it to a stored copy of the current value).
  
  The GC could therefore write the new colour and wait for the interpreter to pick up the change. I could use wait() and notify() here, since the GC doesn't really have to do anything until the interpreter wants to allocate more memory. But this would be designing for at most one worker thread, something I would prefer to avoid.
  
  What about allocation? Suppose we keep a linked list of all free memory chunks, preferably in ready-to-use sizes. Some mechanism would be needed to stop the GC and the allocator from interfering, since both of them are writing to the same list. If we rule that the GC only adds recycled chunks at the end of the list and the allocator only removes chunks from the front of the list, nobody is really in each others way: It wouldn't matter in which order the GC and the allocator arrive at the array, since the GC will traverse the list all the way to the end. If it finds it's not in the free list anymore, it just retries. Following the free list will have to include checking the next pointer for sanity (inside the heap? Don't want to risk a segmentation fault) and while traversing make sure the nodes are all free and of the correct node type. This will have to be thought through, just to be sure we don't run into a race condition here.
  
  An alternate idea would be to have two free lists: One maintained by the collector, the other maintained by the allocator. When the allocator runs out of space, it notifies the collector (write a flag, same problem as above with the current colour) and waits for the collector to feed it more memory.
  
  This all doesn't solve memory defragmentation. Sadly, that is an issue not addressed by Dijkstras GC algorithm. I'm not quite sure if I should come up with a solution or just leave it like it is. With the SinaLanguage design, chunks only ever come in fixed sizes, so compacting might not be an issue at all anyway.

  